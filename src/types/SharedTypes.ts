// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.175.0
//   protoc               v5.26.0
// source: SharedTypes.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "SharedTypes";

export const NSFWLevel = { NSFW_DEFAULT: 0, EXPLICIT: 1, SAFE: 2, AGE_RESTRICTED: 3, UNRECOGNIZED: -1 } as const;

export type NSFWLevel = typeof NSFWLevel[keyof typeof NSFWLevel];

export namespace NSFWLevel {
  export type NSFW_DEFAULT = typeof NSFWLevel.NSFW_DEFAULT;
  export type EXPLICIT = typeof NSFWLevel.EXPLICIT;
  export type SAFE = typeof NSFWLevel.SAFE;
  export type AGE_RESTRICTED = typeof NSFWLevel.AGE_RESTRICTED;
  export type UNRECOGNIZED = typeof NSFWLevel.UNRECOGNIZED;
}

export const GuildHubType = { GUILD_DEFAULT: 0, HIGH_SCHOOL: 1, COLLEGE: 2, UNRECOGNIZED: -1 } as const;

export type GuildHubType = typeof GuildHubType[keyof typeof GuildHubType];

export namespace GuildHubType {
  export type GUILD_DEFAULT = typeof GuildHubType.GUILD_DEFAULT;
  export type HIGH_SCHOOL = typeof GuildHubType.HIGH_SCHOOL;
  export type COLLEGE = typeof GuildHubType.COLLEGE;
  export type UNRECOGNIZED = typeof GuildHubType.UNRECOGNIZED;
}

export const StageInstancePrivacyLevel = { PUBLIC: 0, STAGE_GUILD_ONLY: 1, UNRECOGNIZED: -1 } as const;

export type StageInstancePrivacyLevel = typeof StageInstancePrivacyLevel[keyof typeof StageInstancePrivacyLevel];

export namespace StageInstancePrivacyLevel {
  export type PUBLIC = typeof StageInstancePrivacyLevel.PUBLIC;
  export type STAGE_GUILD_ONLY = typeof StageInstancePrivacyLevel.STAGE_GUILD_ONLY;
  export type UNRECOGNIZED = typeof StageInstancePrivacyLevel.UNRECOGNIZED;
}

export const RoleFlags = { IN_PROMPT: 0, UNRECOGNIZED: -1 } as const;

export type RoleFlags = typeof RoleFlags[keyof typeof RoleFlags];

export namespace RoleFlags {
  export type IN_PROMPT = typeof RoleFlags.IN_PROMPT;
  export type UNRECOGNIZED = typeof RoleFlags.UNRECOGNIZED;
}

export const GuildScheduledEventPrivacyLevel = { GUILD_ONLY: 0, UNRECOGNIZED: -1 } as const;

export type GuildScheduledEventPrivacyLevel =
  typeof GuildScheduledEventPrivacyLevel[keyof typeof GuildScheduledEventPrivacyLevel];

export namespace GuildScheduledEventPrivacyLevel {
  export type GUILD_ONLY = typeof GuildScheduledEventPrivacyLevel.GUILD_ONLY;
  export type UNRECOGNIZED = typeof GuildScheduledEventPrivacyLevel.UNRECOGNIZED;
}

export const GuildScheduledEventStatus = {
  SCHEDULED: 0,
  ACTIVE: 1,
  COMPLETED: 2,
  CANCELED: 3,
  UNRECOGNIZED: -1,
} as const;

export type GuildScheduledEventStatus = typeof GuildScheduledEventStatus[keyof typeof GuildScheduledEventStatus];

export namespace GuildScheduledEventStatus {
  export type SCHEDULED = typeof GuildScheduledEventStatus.SCHEDULED;
  export type ACTIVE = typeof GuildScheduledEventStatus.ACTIVE;
  export type COMPLETED = typeof GuildScheduledEventStatus.COMPLETED;
  export type CANCELED = typeof GuildScheduledEventStatus.CANCELED;
  export type UNRECOGNIZED = typeof GuildScheduledEventStatus.UNRECOGNIZED;
}

export const GuildScheduledEventType = { STAGE_INSTANCE: 0, VOICE: 1, EXTERNAL: 2, UNRECOGNIZED: -1 } as const;

export type GuildScheduledEventType = typeof GuildScheduledEventType[keyof typeof GuildScheduledEventType];

export namespace GuildScheduledEventType {
  export type STAGE_INSTANCE = typeof GuildScheduledEventType.STAGE_INSTANCE;
  export type VOICE = typeof GuildScheduledEventType.VOICE;
  export type EXTERNAL = typeof GuildScheduledEventType.EXTERNAL;
  export type UNRECOGNIZED = typeof GuildScheduledEventType.UNRECOGNIZED;
}

export const ChannelSortOrder = { LATEST_ACTIVITY: 0, CREATION_DATE: 1, UNRECOGNIZED: -1 } as const;

export type ChannelSortOrder = typeof ChannelSortOrder[keyof typeof ChannelSortOrder];

export namespace ChannelSortOrder {
  export type LATEST_ACTIVITY = typeof ChannelSortOrder.LATEST_ACTIVITY;
  export type CREATION_DATE = typeof ChannelSortOrder.CREATION_DATE;
  export type UNRECOGNIZED = typeof ChannelSortOrder.UNRECOGNIZED;
}

export const ForumLayout = { NOT_SET: 0, LIST_VIEW: 1, GALLERY_VIEW: 2, UNRECOGNIZED: -1 } as const;

export type ForumLayout = typeof ForumLayout[keyof typeof ForumLayout];

export namespace ForumLayout {
  export type NOT_SET = typeof ForumLayout.NOT_SET;
  export type LIST_VIEW = typeof ForumLayout.LIST_VIEW;
  export type GALLERY_VIEW = typeof ForumLayout.GALLERY_VIEW;
  export type UNRECOGNIZED = typeof ForumLayout.UNRECOGNIZED;
}

export const ChannelType = {
  GUILD_TEXT: 0,
  GUILD_VOICE: 1,
  GROUP_DM: 2,
  GUILD_CATEGORY: 3,
  GUILD_ANNOUNCEMENT: 4,
  ANNOUNCEMENT_THREAD: 5,
  PUBLIC_THREAD: 10,
  PRIVATE_THREAD: 11,
  GUILD_STAGE_VOICE: 12,
  GUILD_DIRECTORY: 13,
  GUILD_FORUM: 14,
  GUILD_MEDIA: 15,
  UNRECOGNIZED: -1,
} as const;

export type ChannelType = typeof ChannelType[keyof typeof ChannelType];

export namespace ChannelType {
  export type GUILD_TEXT = typeof ChannelType.GUILD_TEXT;
  export type GUILD_VOICE = typeof ChannelType.GUILD_VOICE;
  export type GROUP_DM = typeof ChannelType.GROUP_DM;
  export type GUILD_CATEGORY = typeof ChannelType.GUILD_CATEGORY;
  export type GUILD_ANNOUNCEMENT = typeof ChannelType.GUILD_ANNOUNCEMENT;
  export type ANNOUNCEMENT_THREAD = typeof ChannelType.ANNOUNCEMENT_THREAD;
  export type PUBLIC_THREAD = typeof ChannelType.PUBLIC_THREAD;
  export type PRIVATE_THREAD = typeof ChannelType.PRIVATE_THREAD;
  export type GUILD_STAGE_VOICE = typeof ChannelType.GUILD_STAGE_VOICE;
  export type GUILD_DIRECTORY = typeof ChannelType.GUILD_DIRECTORY;
  export type GUILD_FORUM = typeof ChannelType.GUILD_FORUM;
  export type GUILD_MEDIA = typeof ChannelType.GUILD_MEDIA;
  export type UNRECOGNIZED = typeof ChannelType.UNRECOGNIZED;
}

export const VideoQualityMode = { AUTO: 0, FULL: 1, UNRECOGNIZED: -1 } as const;

export type VideoQualityMode = typeof VideoQualityMode[keyof typeof VideoQualityMode];

export namespace VideoQualityMode {
  export type AUTO = typeof VideoQualityMode.AUTO;
  export type FULL = typeof VideoQualityMode.FULL;
  export type UNRECOGNIZED = typeof VideoQualityMode.UNRECOGNIZED;
}

export const OverwriteType = { ROLE: 0, MEMBER: 1, UNRECOGNIZED: -1 } as const;

export type OverwriteType = typeof OverwriteType[keyof typeof OverwriteType];

export namespace OverwriteType {
  export type ROLE = typeof OverwriteType.ROLE;
  export type MEMBER = typeof OverwriteType.MEMBER;
  export type UNRECOGNIZED = typeof OverwriteType.UNRECOGNIZED;
}

export const ApplicationComandTypes = { CHAT_INPUT: 0, USER: 1, MESSAGE: 2, UNRECOGNIZED: -1 } as const;

export type ApplicationComandTypes = typeof ApplicationComandTypes[keyof typeof ApplicationComandTypes];

export namespace ApplicationComandTypes {
  export type CHAT_INPUT = typeof ApplicationComandTypes.CHAT_INPUT;
  export type USER = typeof ApplicationComandTypes.USER;
  export type MESSAGE = typeof ApplicationComandTypes.MESSAGE;
  export type UNRECOGNIZED = typeof ApplicationComandTypes.UNRECOGNIZED;
}

export const StickerType = { STANDARD: 0, GUILD: 1, UNRECOGNIZED: -1 } as const;

export type StickerType = typeof StickerType[keyof typeof StickerType];

export namespace StickerType {
  export type STANDARD = typeof StickerType.STANDARD;
  export type GUILD = typeof StickerType.GUILD;
  export type UNRECOGNIZED = typeof StickerType.UNRECOGNIZED;
}

export const StickerFormatType = { PNG: 0, APNG: 1, LOTTie: 2, GIF: 3, UNRECOGNIZED: -1 } as const;

export type StickerFormatType = typeof StickerFormatType[keyof typeof StickerFormatType];

export namespace StickerFormatType {
  export type PNG = typeof StickerFormatType.PNG;
  export type APNG = typeof StickerFormatType.APNG;
  export type LOTTie = typeof StickerFormatType.LOTTie;
  export type GIF = typeof StickerFormatType.GIF;
  export type UNRECOGNIZED = typeof StickerFormatType.UNRECOGNIZED;
}

export const PremiumType = { NONE: 0, NITRO_CLASSIC: 1, NITRO: 2, NITRO_BASIC: 3, UNRECOGNIZED: -1 } as const;

export type PremiumType = typeof PremiumType[keyof typeof PremiumType];

export namespace PremiumType {
  export type NONE = typeof PremiumType.NONE;
  export type NITRO_CLASSIC = typeof PremiumType.NITRO_CLASSIC;
  export type NITRO = typeof PremiumType.NITRO;
  export type NITRO_BASIC = typeof PremiumType.NITRO_BASIC;
  export type UNRECOGNIZED = typeof PremiumType.UNRECOGNIZED;
}

/** if field doesnt exist in the official documentation its marked as optional */
export interface Guild {
  version?: number | undefined;
  threads: Channel[];
  stickers: Sticker[];
  stageInstances: StageInstance[];
  roles: Role[];
  properties: GuildProperties | undefined;
  premiumSubscriptionCount?: number | undefined;
  memberCount: number;
  lazy?: boolean | undefined;
  large?: boolean | undefined;
  joinedAt: string;
  id: string;
  guildScheduledEvents: GuildScheduledEvent[];
  emojis: Emoji[];
  dataMode?: string | undefined;
  channels: Channel[];
  applicationCommandCounts: ApplicationCommandCounts | undefined;
}

export interface GuildProperties {
  id: string;
  ownerId: string;
  description?: string | undefined;
  icon?: string | undefined;
  name: string;
  nsfwLevel: NSFWLevel;
  nsfw: boolean;
  explicitContentFilter: number;
  systemChannelFlags: number;
  verificationLevel: number;
  mfaLevel: number;
  preferredLocale: string;
  hubType?: GuildHubType | undefined;
  homeHeader?: string | undefined;
  rulesChannelId?: string | undefined;
  systemChannelId?: string | undefined;
  publicUpdatesChannelId?: string | undefined;
  safetyAlertsChannelId?: string | undefined;
  afkTimeout: number;
  afkChannelId?: string | undefined;
  premiumTier: number;
  premiumProgressBarEnabled: boolean;
  splash?: string | undefined;
  features: string[];
  defaultMessageNotifications: number;
  banner?: string | undefined;
  vanityUrlCode?: string | undefined;
  latestOnboardingQuestionId?: string | undefined;
  maxVideoChannelUsers: number;
  maxStageVideoChannelUsers: number;
  maxMembers: number;
  applicationId?: string | undefined;
}

export interface Sticker {
  id: string;
  packId?: string | undefined;
  name: string;
  description?: string | undefined;
  tags: string[];
  asset?: string | undefined;
  type: StickerType;
  formatType: StickerFormatType;
  available?: boolean | undefined;
  guildId?: string | undefined;
  user?: User | undefined;
  sortValue?: number | undefined;
}

export interface StageInstance {
  channelId: string;
  discoverableDisabled: boolean;
  guildId: string;
  guildScheduledEventId?: string | undefined;
  id: string;
  privacyLevel: StageInstancePrivacyLevel;
  topic: string;
}

export interface Role {
  unicodeEmoji?: string | undefined;
  flags: RoleFlags;
  hoist: boolean;
  icon?: string | undefined;
  id: string;
  managed: boolean;
  mentionable: boolean;
  name: string;
  permissions: string;
  position: number;
  tags?: RoleTags | undefined;
  color: number;
}

export interface RoleTags {
  availableForPurchase?: boolean | undefined;
  botId?: string | undefined;
  guildConnections?: boolean | undefined;
  integrationId?: string | undefined;
  premiumSubscriber?: boolean | undefined;
  subscriptionListingId?: string | undefined;
}

export interface GuildScheduledEvent {
  id: string;
  guildId: string;
  channelId?: string | undefined;
  creatorId?: string | undefined;
  name: string;
  description?: string | undefined;
  scheduledStartTime: string;
  scheduledEndTime?: string | undefined;
  privacyLevel: StageInstancePrivacyLevel;
  status: GuildScheduledEventStatus;
  entityType: GuildScheduledEventType;
  entityId?: string | undefined;
  entityMetadata?: GuildScheduledEventMetadata | undefined;
  creator?: User | undefined;
  userCount?: number | undefined;
  image?: string | undefined;
}

export interface GuildScheduledEventMetadata {
  location?: string | undefined;
}

export interface Emoji {
  id: string;
  name?: string | undefined;
  roles: Role[];
  user?: User | undefined;
  requireColons?: boolean | undefined;
  managed?: boolean | undefined;
  animated?: boolean | undefined;
  available?: boolean | undefined;
}

export interface Channel {
  id: string;
  type: ChannelType;
  guildId?: string | undefined;
  position?: number | undefined;
  permissionOverwrites: OverwriteObject[];
  name?: string | undefined;
  topic?: string | undefined;
  nsfw?: boolean | undefined;
  lastMessageId?: string | undefined;
  bitrate?: number | undefined;
  userLimit?: number | undefined;
  rateLimitPerUser?: number | undefined;
  recipients: User[];
  icon?: string | undefined;
  ownerId?: string | undefined;
  applicationId?: string | undefined;
  managed?: boolean | undefined;
  parentId?: string | undefined;
  lastPinTimestamp?: number | undefined;
  rtcRegion?: string | undefined;
  videoQualityMode?: VideoQualityMode | undefined;
  messageCount?: number | undefined;
  memberCount?: number | undefined;
  threadMetadata?: ThreadMetadata | undefined;
  member?: ThreadMember | undefined;
  defaultAutoArchiveDuration?: number | undefined;
  permissions?: string | undefined;
  flags?: number | undefined;
  totalMessageSent?: number | undefined;
  availableTags: ForumTag[];
  appliedTags: string[];
  defaultReactionEmoji?: DefaultReaction | undefined;
  defaultThreadRateLimitPerUser?: number | undefined;
  defaultSortOrder?: ChannelSortOrder | undefined;
  defaultForumLayout?: ForumLayout | undefined;
}

export interface DefaultReaction {
  emojiId?: string | undefined;
  emojiName?: string | undefined;
}

export interface ForumTag {
  id: string;
  name: string;
  moderated: boolean;
  emojiId?: string | undefined;
  emojiName?: string | undefined;
}

export interface ThreadMetadata {
  archived: boolean;
  autoArchiveDuration: number;
  archiveTimestamp: number;
  locked: boolean;
  invitable?: boolean | undefined;
  createTimestamp?: number | undefined;
}

export interface ThreadMember {
  id?: string | undefined;
  userId?: string | undefined;
  joinTimestamp: number;
  flags: number;
  member?: GuildMember | undefined;
}

export interface OverwriteObject {
  id: string;
  type: OverwriteType;
  allow: string;
  deny: string;
}

export interface ApplicationCommandCounts {
  messages?: number | undefined;
  users?: number | undefined;
  chatInputs?: number | undefined;
}

export interface User {
  id: string;
  username: string;
  discriminator: string;
  globalName?: string | undefined;
  avatar?: string | undefined;
  bot?: boolean | undefined;
  system?: boolean | undefined;
  mfaEnabled?: boolean | undefined;
  banner?: string | undefined;
  accentColor?: number | undefined;
  locale?: string | undefined;
  verified?: boolean | undefined;
  email?: string | undefined;
  flags?: number | undefined;
  premiumType?: PremiumType | undefined;
  publicFlags?: number | undefined;
  avatarDecoration?: string | undefined;
}

export interface GuildMember {
  user?: User | undefined;
  nick?: string | undefined;
  avatar?: string | undefined;
  roles: Role[];
  joinedAt: number;
  premiumSince?: number | undefined;
  deaf: boolean;
  mute: boolean;
  flags: number;
  pending?: boolean | undefined;
  permissions?: string | undefined;
  communicationDisabledUntil?: number | undefined;
}

function createBaseGuild(): Guild {
  return {
    version: undefined,
    threads: [],
    stickers: [],
    stageInstances: [],
    roles: [],
    properties: undefined,
    premiumSubscriptionCount: undefined,
    memberCount: 0,
    lazy: undefined,
    large: undefined,
    joinedAt: "",
    id: "",
    guildScheduledEvents: [],
    emojis: [],
    dataMode: undefined,
    channels: [],
    applicationCommandCounts: undefined,
  };
}

export const Guild = {
  encode(message: Guild, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== undefined) {
      writer.uint32(8).uint64(message.version);
    }
    for (const v of message.threads) {
      Channel.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.stickers) {
      Sticker.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.stageInstances) {
      StageInstance.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.properties !== undefined) {
      GuildProperties.encode(message.properties, writer.uint32(50).fork()).ldelim();
    }
    if (message.premiumSubscriptionCount !== undefined) {
      writer.uint32(56).uint64(message.premiumSubscriptionCount);
    }
    if (message.memberCount !== 0) {
      writer.uint32(64).uint64(message.memberCount);
    }
    if (message.lazy !== undefined) {
      writer.uint32(72).bool(message.lazy);
    }
    if (message.large !== undefined) {
      writer.uint32(80).bool(message.large);
    }
    if (message.joinedAt !== "") {
      writer.uint32(90).string(message.joinedAt);
    }
    if (message.id !== "") {
      writer.uint32(98).string(message.id);
    }
    for (const v of message.guildScheduledEvents) {
      GuildScheduledEvent.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    for (const v of message.emojis) {
      Emoji.encode(v!, writer.uint32(114).fork()).ldelim();
    }
    if (message.dataMode !== undefined) {
      writer.uint32(122).string(message.dataMode);
    }
    for (const v of message.channels) {
      Channel.encode(v!, writer.uint32(130).fork()).ldelim();
    }
    if (message.applicationCommandCounts !== undefined) {
      ApplicationCommandCounts.encode(message.applicationCommandCounts, writer.uint32(138).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Guild {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuild();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.threads.push(Channel.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stickers.push(Sticker.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stageInstances.push(StageInstance.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.properties = GuildProperties.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.premiumSubscriptionCount = longToNumber(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.memberCount = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.lazy = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.large = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.joinedAt = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.id = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.guildScheduledEvents.push(GuildScheduledEvent.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.emojis.push(Emoji.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.dataMode = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.channels.push(Channel.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.applicationCommandCounts = ApplicationCommandCounts.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Guild>, I>>(base?: I): Guild {
    return Guild.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Guild>, I>>(object: I): Guild {
    const message = createBaseGuild();
    message.version = object.version ?? undefined;
    message.threads = object.threads?.map((e) => Channel.fromPartial(e)) || [];
    message.stickers = object.stickers?.map((e) => Sticker.fromPartial(e)) || [];
    message.stageInstances = object.stageInstances?.map((e) => StageInstance.fromPartial(e)) || [];
    message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? GuildProperties.fromPartial(object.properties)
      : undefined;
    message.premiumSubscriptionCount = object.premiumSubscriptionCount ?? undefined;
    message.memberCount = object.memberCount ?? 0;
    message.lazy = object.lazy ?? undefined;
    message.large = object.large ?? undefined;
    message.joinedAt = object.joinedAt ?? "";
    message.id = object.id ?? "";
    message.guildScheduledEvents = object.guildScheduledEvents?.map((e) => GuildScheduledEvent.fromPartial(e)) || [];
    message.emojis = object.emojis?.map((e) => Emoji.fromPartial(e)) || [];
    message.dataMode = object.dataMode ?? undefined;
    message.channels = object.channels?.map((e) => Channel.fromPartial(e)) || [];
    message.applicationCommandCounts =
      (object.applicationCommandCounts !== undefined && object.applicationCommandCounts !== null)
        ? ApplicationCommandCounts.fromPartial(object.applicationCommandCounts)
        : undefined;
    return message;
  },
};

function createBaseGuildProperties(): GuildProperties {
  return {
    id: "",
    ownerId: "",
    description: undefined,
    icon: undefined,
    name: "",
    nsfwLevel: 0,
    nsfw: false,
    explicitContentFilter: 0,
    systemChannelFlags: 0,
    verificationLevel: 0,
    mfaLevel: 0,
    preferredLocale: "",
    hubType: undefined,
    homeHeader: undefined,
    rulesChannelId: undefined,
    systemChannelId: undefined,
    publicUpdatesChannelId: undefined,
    safetyAlertsChannelId: undefined,
    afkTimeout: 0,
    afkChannelId: undefined,
    premiumTier: 0,
    premiumProgressBarEnabled: false,
    splash: undefined,
    features: [],
    defaultMessageNotifications: 0,
    banner: undefined,
    vanityUrlCode: undefined,
    latestOnboardingQuestionId: undefined,
    maxVideoChannelUsers: 0,
    maxStageVideoChannelUsers: 0,
    maxMembers: 0,
    applicationId: undefined,
  };
}

export const GuildProperties = {
  encode(message: GuildProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.ownerId !== "") {
      writer.uint32(18).string(message.ownerId);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.icon !== undefined) {
      writer.uint32(34).string(message.icon);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.nsfwLevel !== 0) {
      writer.uint32(48).int32(message.nsfwLevel);
    }
    if (message.nsfw !== false) {
      writer.uint32(56).bool(message.nsfw);
    }
    if (message.explicitContentFilter !== 0) {
      writer.uint32(64).uint64(message.explicitContentFilter);
    }
    if (message.systemChannelFlags !== 0) {
      writer.uint32(72).uint32(message.systemChannelFlags);
    }
    if (message.verificationLevel !== 0) {
      writer.uint32(80).uint32(message.verificationLevel);
    }
    if (message.mfaLevel !== 0) {
      writer.uint32(88).uint32(message.mfaLevel);
    }
    if (message.preferredLocale !== "") {
      writer.uint32(98).string(message.preferredLocale);
    }
    if (message.hubType !== undefined) {
      writer.uint32(104).int32(message.hubType);
    }
    if (message.homeHeader !== undefined) {
      writer.uint32(114).string(message.homeHeader);
    }
    if (message.rulesChannelId !== undefined) {
      writer.uint32(122).string(message.rulesChannelId);
    }
    if (message.systemChannelId !== undefined) {
      writer.uint32(130).string(message.systemChannelId);
    }
    if (message.publicUpdatesChannelId !== undefined) {
      writer.uint32(138).string(message.publicUpdatesChannelId);
    }
    if (message.safetyAlertsChannelId !== undefined) {
      writer.uint32(146).string(message.safetyAlertsChannelId);
    }
    if (message.afkTimeout !== 0) {
      writer.uint32(152).uint64(message.afkTimeout);
    }
    if (message.afkChannelId !== undefined) {
      writer.uint32(162).string(message.afkChannelId);
    }
    if (message.premiumTier !== 0) {
      writer.uint32(168).uint64(message.premiumTier);
    }
    if (message.premiumProgressBarEnabled !== false) {
      writer.uint32(176).bool(message.premiumProgressBarEnabled);
    }
    if (message.splash !== undefined) {
      writer.uint32(186).string(message.splash);
    }
    for (const v of message.features) {
      writer.uint32(194).string(v!);
    }
    if (message.defaultMessageNotifications !== 0) {
      writer.uint32(200).uint64(message.defaultMessageNotifications);
    }
    if (message.banner !== undefined) {
      writer.uint32(210).string(message.banner);
    }
    if (message.vanityUrlCode !== undefined) {
      writer.uint32(218).string(message.vanityUrlCode);
    }
    if (message.latestOnboardingQuestionId !== undefined) {
      writer.uint32(226).string(message.latestOnboardingQuestionId);
    }
    if (message.maxVideoChannelUsers !== 0) {
      writer.uint32(232).uint64(message.maxVideoChannelUsers);
    }
    if (message.maxStageVideoChannelUsers !== 0) {
      writer.uint32(240).uint64(message.maxStageVideoChannelUsers);
    }
    if (message.maxMembers !== 0) {
      writer.uint32(248).uint64(message.maxMembers);
    }
    if (message.applicationId !== undefined) {
      writer.uint32(258).string(message.applicationId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GuildProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuildProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.icon = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nsfwLevel = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.nsfw = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.explicitContentFilter = longToNumber(reader.uint64() as Long);
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.systemChannelFlags = reader.uint32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.verificationLevel = reader.uint32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.mfaLevel = reader.uint32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.preferredLocale = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.hubType = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.homeHeader = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.rulesChannelId = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.systemChannelId = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.publicUpdatesChannelId = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.safetyAlertsChannelId = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.afkTimeout = longToNumber(reader.uint64() as Long);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.afkChannelId = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.premiumTier = longToNumber(reader.uint64() as Long);
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.premiumProgressBarEnabled = reader.bool();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.splash = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.features.push(reader.string());
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.defaultMessageNotifications = longToNumber(reader.uint64() as Long);
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.banner = reader.string();
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.vanityUrlCode = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.latestOnboardingQuestionId = reader.string();
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.maxVideoChannelUsers = longToNumber(reader.uint64() as Long);
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.maxStageVideoChannelUsers = longToNumber(reader.uint64() as Long);
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.maxMembers = longToNumber(reader.uint64() as Long);
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.applicationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GuildProperties>, I>>(base?: I): GuildProperties {
    return GuildProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GuildProperties>, I>>(object: I): GuildProperties {
    const message = createBaseGuildProperties();
    message.id = object.id ?? "";
    message.ownerId = object.ownerId ?? "";
    message.description = object.description ?? undefined;
    message.icon = object.icon ?? undefined;
    message.name = object.name ?? "";
    message.nsfwLevel = object.nsfwLevel ?? 0;
    message.nsfw = object.nsfw ?? false;
    message.explicitContentFilter = object.explicitContentFilter ?? 0;
    message.systemChannelFlags = object.systemChannelFlags ?? 0;
    message.verificationLevel = object.verificationLevel ?? 0;
    message.mfaLevel = object.mfaLevel ?? 0;
    message.preferredLocale = object.preferredLocale ?? "";
    message.hubType = object.hubType ?? undefined;
    message.homeHeader = object.homeHeader ?? undefined;
    message.rulesChannelId = object.rulesChannelId ?? undefined;
    message.systemChannelId = object.systemChannelId ?? undefined;
    message.publicUpdatesChannelId = object.publicUpdatesChannelId ?? undefined;
    message.safetyAlertsChannelId = object.safetyAlertsChannelId ?? undefined;
    message.afkTimeout = object.afkTimeout ?? 0;
    message.afkChannelId = object.afkChannelId ?? undefined;
    message.premiumTier = object.premiumTier ?? 0;
    message.premiumProgressBarEnabled = object.premiumProgressBarEnabled ?? false;
    message.splash = object.splash ?? undefined;
    message.features = object.features?.map((e) => e) || [];
    message.defaultMessageNotifications = object.defaultMessageNotifications ?? 0;
    message.banner = object.banner ?? undefined;
    message.vanityUrlCode = object.vanityUrlCode ?? undefined;
    message.latestOnboardingQuestionId = object.latestOnboardingQuestionId ?? undefined;
    message.maxVideoChannelUsers = object.maxVideoChannelUsers ?? 0;
    message.maxStageVideoChannelUsers = object.maxStageVideoChannelUsers ?? 0;
    message.maxMembers = object.maxMembers ?? 0;
    message.applicationId = object.applicationId ?? undefined;
    return message;
  },
};

function createBaseSticker(): Sticker {
  return {
    id: "",
    packId: undefined,
    name: "",
    description: undefined,
    tags: [],
    asset: undefined,
    type: 0,
    formatType: 0,
    available: undefined,
    guildId: undefined,
    user: undefined,
    sortValue: undefined,
  };
}

export const Sticker = {
  encode(message: Sticker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.packId !== undefined) {
      writer.uint32(18).string(message.packId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.tags) {
      writer.uint32(42).string(v!);
    }
    if (message.asset !== undefined) {
      writer.uint32(50).string(message.asset);
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.formatType !== 0) {
      writer.uint32(64).int32(message.formatType);
    }
    if (message.available !== undefined) {
      writer.uint32(72).bool(message.available);
    }
    if (message.guildId !== undefined) {
      writer.uint32(82).string(message.guildId);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(90).fork()).ldelim();
    }
    if (message.sortValue !== undefined) {
      writer.uint32(96).uint64(message.sortValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Sticker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSticker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.packId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.formatType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.available = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.guildId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.sortValue = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Sticker>, I>>(base?: I): Sticker {
    return Sticker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Sticker>, I>>(object: I): Sticker {
    const message = createBaseSticker();
    message.id = object.id ?? "";
    message.packId = object.packId ?? undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.asset = object.asset ?? undefined;
    message.type = object.type ?? 0;
    message.formatType = object.formatType ?? 0;
    message.available = object.available ?? undefined;
    message.guildId = object.guildId ?? undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.sortValue = object.sortValue ?? undefined;
    return message;
  },
};

function createBaseStageInstance(): StageInstance {
  return {
    channelId: "",
    discoverableDisabled: false,
    guildId: "",
    guildScheduledEventId: undefined,
    id: "",
    privacyLevel: 0,
    topic: "",
  };
}

export const StageInstance = {
  encode(message: StageInstance, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.discoverableDisabled !== false) {
      writer.uint32(16).bool(message.discoverableDisabled);
    }
    if (message.guildId !== "") {
      writer.uint32(26).string(message.guildId);
    }
    if (message.guildScheduledEventId !== undefined) {
      writer.uint32(34).string(message.guildScheduledEventId);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    if (message.privacyLevel !== 0) {
      writer.uint32(48).int32(message.privacyLevel);
    }
    if (message.topic !== "") {
      writer.uint32(58).string(message.topic);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StageInstance {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStageInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.discoverableDisabled = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.guildId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.guildScheduledEventId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.privacyLevel = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.topic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<StageInstance>, I>>(base?: I): StageInstance {
    return StageInstance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StageInstance>, I>>(object: I): StageInstance {
    const message = createBaseStageInstance();
    message.channelId = object.channelId ?? "";
    message.discoverableDisabled = object.discoverableDisabled ?? false;
    message.guildId = object.guildId ?? "";
    message.guildScheduledEventId = object.guildScheduledEventId ?? undefined;
    message.id = object.id ?? "";
    message.privacyLevel = object.privacyLevel ?? 0;
    message.topic = object.topic ?? "";
    return message;
  },
};

function createBaseRole(): Role {
  return {
    unicodeEmoji: undefined,
    flags: 0,
    hoist: false,
    icon: undefined,
    id: "",
    managed: false,
    mentionable: false,
    name: "",
    permissions: "",
    position: 0,
    tags: undefined,
    color: 0,
  };
}

export const Role = {
  encode(message: Role, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.unicodeEmoji !== undefined) {
      writer.uint32(10).string(message.unicodeEmoji);
    }
    if (message.flags !== 0) {
      writer.uint32(16).int32(message.flags);
    }
    if (message.hoist !== false) {
      writer.uint32(24).bool(message.hoist);
    }
    if (message.icon !== undefined) {
      writer.uint32(34).string(message.icon);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    if (message.managed !== false) {
      writer.uint32(48).bool(message.managed);
    }
    if (message.mentionable !== false) {
      writer.uint32(56).bool(message.mentionable);
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    if (message.permissions !== "") {
      writer.uint32(74).string(message.permissions);
    }
    if (message.position !== 0) {
      writer.uint32(80).uint64(message.position);
    }
    if (message.tags !== undefined) {
      RoleTags.encode(message.tags, writer.uint32(90).fork()).ldelim();
    }
    if (message.color !== 0) {
      writer.uint32(96).uint64(message.color);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Role {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unicodeEmoji = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.flags = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.hoist = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.icon = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.managed = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.mentionable = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.name = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.permissions = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.position = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.tags = RoleTags.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.color = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Role>, I>>(base?: I): Role {
    return Role.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Role>, I>>(object: I): Role {
    const message = createBaseRole();
    message.unicodeEmoji = object.unicodeEmoji ?? undefined;
    message.flags = object.flags ?? 0;
    message.hoist = object.hoist ?? false;
    message.icon = object.icon ?? undefined;
    message.id = object.id ?? "";
    message.managed = object.managed ?? false;
    message.mentionable = object.mentionable ?? false;
    message.name = object.name ?? "";
    message.permissions = object.permissions ?? "";
    message.position = object.position ?? 0;
    message.tags = (object.tags !== undefined && object.tags !== null) ? RoleTags.fromPartial(object.tags) : undefined;
    message.color = object.color ?? 0;
    return message;
  },
};

function createBaseRoleTags(): RoleTags {
  return {
    availableForPurchase: undefined,
    botId: undefined,
    guildConnections: undefined,
    integrationId: undefined,
    premiumSubscriber: undefined,
    subscriptionListingId: undefined,
  };
}

export const RoleTags = {
  encode(message: RoleTags, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.availableForPurchase !== undefined) {
      writer.uint32(8).bool(message.availableForPurchase);
    }
    if (message.botId !== undefined) {
      writer.uint32(18).string(message.botId);
    }
    if (message.guildConnections !== undefined) {
      writer.uint32(24).bool(message.guildConnections);
    }
    if (message.integrationId !== undefined) {
      writer.uint32(34).string(message.integrationId);
    }
    if (message.premiumSubscriber !== undefined) {
      writer.uint32(40).bool(message.premiumSubscriber);
    }
    if (message.subscriptionListingId !== undefined) {
      writer.uint32(50).string(message.subscriptionListingId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoleTags {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleTags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.availableForPurchase = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.botId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.guildConnections = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.integrationId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.premiumSubscriber = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.subscriptionListingId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<RoleTags>, I>>(base?: I): RoleTags {
    return RoleTags.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RoleTags>, I>>(object: I): RoleTags {
    const message = createBaseRoleTags();
    message.availableForPurchase = object.availableForPurchase ?? undefined;
    message.botId = object.botId ?? undefined;
    message.guildConnections = object.guildConnections ?? undefined;
    message.integrationId = object.integrationId ?? undefined;
    message.premiumSubscriber = object.premiumSubscriber ?? undefined;
    message.subscriptionListingId = object.subscriptionListingId ?? undefined;
    return message;
  },
};

function createBaseGuildScheduledEvent(): GuildScheduledEvent {
  return {
    id: "",
    guildId: "",
    channelId: undefined,
    creatorId: undefined,
    name: "",
    description: undefined,
    scheduledStartTime: "",
    scheduledEndTime: undefined,
    privacyLevel: 0,
    status: 0,
    entityType: 0,
    entityId: undefined,
    entityMetadata: undefined,
    creator: undefined,
    userCount: undefined,
    image: undefined,
  };
}

export const GuildScheduledEvent = {
  encode(message: GuildScheduledEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.channelId !== undefined) {
      writer.uint32(26).string(message.channelId);
    }
    if (message.creatorId !== undefined) {
      writer.uint32(34).string(message.creatorId);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    if (message.scheduledStartTime !== "") {
      writer.uint32(58).string(message.scheduledStartTime);
    }
    if (message.scheduledEndTime !== undefined) {
      writer.uint32(66).string(message.scheduledEndTime);
    }
    if (message.privacyLevel !== 0) {
      writer.uint32(72).int32(message.privacyLevel);
    }
    if (message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    if (message.entityType !== 0) {
      writer.uint32(88).int32(message.entityType);
    }
    if (message.entityId !== undefined) {
      writer.uint32(98).string(message.entityId);
    }
    if (message.entityMetadata !== undefined) {
      GuildScheduledEventMetadata.encode(message.entityMetadata, writer.uint32(106).fork()).ldelim();
    }
    if (message.creator !== undefined) {
      User.encode(message.creator, writer.uint32(114).fork()).ldelim();
    }
    if (message.userCount !== undefined) {
      writer.uint32(120).uint64(message.userCount);
    }
    if (message.image !== undefined) {
      writer.uint32(130).string(message.image);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GuildScheduledEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuildScheduledEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scheduledStartTime = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scheduledEndTime = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.privacyLevel = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.entityType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.entityMetadata = GuildScheduledEventMetadata.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.creator = User.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.userCount = longToNumber(reader.uint64() as Long);
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.image = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GuildScheduledEvent>, I>>(base?: I): GuildScheduledEvent {
    return GuildScheduledEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GuildScheduledEvent>, I>>(object: I): GuildScheduledEvent {
    const message = createBaseGuildScheduledEvent();
    message.id = object.id ?? "";
    message.guildId = object.guildId ?? "";
    message.channelId = object.channelId ?? undefined;
    message.creatorId = object.creatorId ?? undefined;
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.scheduledStartTime = object.scheduledStartTime ?? "";
    message.scheduledEndTime = object.scheduledEndTime ?? undefined;
    message.privacyLevel = object.privacyLevel ?? 0;
    message.status = object.status ?? 0;
    message.entityType = object.entityType ?? 0;
    message.entityId = object.entityId ?? undefined;
    message.entityMetadata = (object.entityMetadata !== undefined && object.entityMetadata !== null)
      ? GuildScheduledEventMetadata.fromPartial(object.entityMetadata)
      : undefined;
    message.creator = (object.creator !== undefined && object.creator !== null)
      ? User.fromPartial(object.creator)
      : undefined;
    message.userCount = object.userCount ?? undefined;
    message.image = object.image ?? undefined;
    return message;
  },
};

function createBaseGuildScheduledEventMetadata(): GuildScheduledEventMetadata {
  return { location: undefined };
}

export const GuildScheduledEventMetadata = {
  encode(message: GuildScheduledEventMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.location !== undefined) {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GuildScheduledEventMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuildScheduledEventMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GuildScheduledEventMetadata>, I>>(base?: I): GuildScheduledEventMetadata {
    return GuildScheduledEventMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GuildScheduledEventMetadata>, I>>(object: I): GuildScheduledEventMetadata {
    const message = createBaseGuildScheduledEventMetadata();
    message.location = object.location ?? undefined;
    return message;
  },
};

function createBaseEmoji(): Emoji {
  return {
    id: "",
    name: undefined,
    roles: [],
    user: undefined,
    requireColons: undefined,
    managed: undefined,
    animated: undefined,
    available: undefined,
  };
}

export const Emoji = {
  encode(message: Emoji, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(34).fork()).ldelim();
    }
    if (message.requireColons !== undefined) {
      writer.uint32(40).bool(message.requireColons);
    }
    if (message.managed !== undefined) {
      writer.uint32(48).bool(message.managed);
    }
    if (message.animated !== undefined) {
      writer.uint32(56).bool(message.animated);
    }
    if (message.available !== undefined) {
      writer.uint32(64).bool(message.available);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Emoji {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoji();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.requireColons = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.managed = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.animated = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.available = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Emoji>, I>>(base?: I): Emoji {
    return Emoji.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Emoji>, I>>(object: I): Emoji {
    const message = createBaseEmoji();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.requireColons = object.requireColons ?? undefined;
    message.managed = object.managed ?? undefined;
    message.animated = object.animated ?? undefined;
    message.available = object.available ?? undefined;
    return message;
  },
};

function createBaseChannel(): Channel {
  return {
    id: "",
    type: 0,
    guildId: undefined,
    position: undefined,
    permissionOverwrites: [],
    name: undefined,
    topic: undefined,
    nsfw: undefined,
    lastMessageId: undefined,
    bitrate: undefined,
    userLimit: undefined,
    rateLimitPerUser: undefined,
    recipients: [],
    icon: undefined,
    ownerId: undefined,
    applicationId: undefined,
    managed: undefined,
    parentId: undefined,
    lastPinTimestamp: undefined,
    rtcRegion: undefined,
    videoQualityMode: undefined,
    messageCount: undefined,
    memberCount: undefined,
    threadMetadata: undefined,
    member: undefined,
    defaultAutoArchiveDuration: undefined,
    permissions: undefined,
    flags: undefined,
    totalMessageSent: undefined,
    availableTags: [],
    appliedTags: [],
    defaultReactionEmoji: undefined,
    defaultThreadRateLimitPerUser: undefined,
    defaultSortOrder: undefined,
    defaultForumLayout: undefined,
  };
}

export const Channel = {
  encode(message: Channel, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.guildId !== undefined) {
      writer.uint32(26).string(message.guildId);
    }
    if (message.position !== undefined) {
      writer.uint32(32).uint64(message.position);
    }
    for (const v of message.permissionOverwrites) {
      OverwriteObject.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.name !== undefined) {
      writer.uint32(50).string(message.name);
    }
    if (message.topic !== undefined) {
      writer.uint32(58).string(message.topic);
    }
    if (message.nsfw !== undefined) {
      writer.uint32(64).bool(message.nsfw);
    }
    if (message.lastMessageId !== undefined) {
      writer.uint32(74).string(message.lastMessageId);
    }
    if (message.bitrate !== undefined) {
      writer.uint32(80).uint64(message.bitrate);
    }
    if (message.userLimit !== undefined) {
      writer.uint32(88).uint64(message.userLimit);
    }
    if (message.rateLimitPerUser !== undefined) {
      writer.uint32(96).uint64(message.rateLimitPerUser);
    }
    for (const v of message.recipients) {
      User.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    if (message.icon !== undefined) {
      writer.uint32(114).string(message.icon);
    }
    if (message.ownerId !== undefined) {
      writer.uint32(122).string(message.ownerId);
    }
    if (message.applicationId !== undefined) {
      writer.uint32(130).string(message.applicationId);
    }
    if (message.managed !== undefined) {
      writer.uint32(136).bool(message.managed);
    }
    if (message.parentId !== undefined) {
      writer.uint32(146).string(message.parentId);
    }
    if (message.lastPinTimestamp !== undefined) {
      writer.uint32(152).uint64(message.lastPinTimestamp);
    }
    if (message.rtcRegion !== undefined) {
      writer.uint32(162).string(message.rtcRegion);
    }
    if (message.videoQualityMode !== undefined) {
      writer.uint32(168).int32(message.videoQualityMode);
    }
    if (message.messageCount !== undefined) {
      writer.uint32(176).uint64(message.messageCount);
    }
    if (message.memberCount !== undefined) {
      writer.uint32(184).uint64(message.memberCount);
    }
    if (message.threadMetadata !== undefined) {
      ThreadMetadata.encode(message.threadMetadata, writer.uint32(194).fork()).ldelim();
    }
    if (message.member !== undefined) {
      ThreadMember.encode(message.member, writer.uint32(202).fork()).ldelim();
    }
    if (message.defaultAutoArchiveDuration !== undefined) {
      writer.uint32(208).uint64(message.defaultAutoArchiveDuration);
    }
    if (message.permissions !== undefined) {
      writer.uint32(218).string(message.permissions);
    }
    if (message.flags !== undefined) {
      writer.uint32(224).uint64(message.flags);
    }
    if (message.totalMessageSent !== undefined) {
      writer.uint32(232).uint64(message.totalMessageSent);
    }
    for (const v of message.availableTags) {
      ForumTag.encode(v!, writer.uint32(242).fork()).ldelim();
    }
    for (const v of message.appliedTags) {
      writer.uint32(250).string(v!);
    }
    if (message.defaultReactionEmoji !== undefined) {
      DefaultReaction.encode(message.defaultReactionEmoji, writer.uint32(258).fork()).ldelim();
    }
    if (message.defaultThreadRateLimitPerUser !== undefined) {
      writer.uint32(264).uint64(message.defaultThreadRateLimitPerUser);
    }
    if (message.defaultSortOrder !== undefined) {
      writer.uint32(272).int32(message.defaultSortOrder);
    }
    if (message.defaultForumLayout !== undefined) {
      writer.uint32(280).int32(message.defaultForumLayout);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Channel {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.guildId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.position = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.permissionOverwrites.push(OverwriteObject.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.nsfw = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.lastMessageId = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.bitrate = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.userLimit = longToNumber(reader.uint64() as Long);
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.rateLimitPerUser = longToNumber(reader.uint64() as Long);
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.recipients.push(User.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.icon = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.ownerId = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.applicationId = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.managed = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.parentId = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.lastPinTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.rtcRegion = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.videoQualityMode = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.messageCount = longToNumber(reader.uint64() as Long);
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.memberCount = longToNumber(reader.uint64() as Long);
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.threadMetadata = ThreadMetadata.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.member = ThreadMember.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.defaultAutoArchiveDuration = longToNumber(reader.uint64() as Long);
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.permissions = reader.string();
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.flags = longToNumber(reader.uint64() as Long);
          continue;
        case 29:
          if (tag !== 232) {
            break;
          }

          message.totalMessageSent = longToNumber(reader.uint64() as Long);
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.availableTags.push(ForumTag.decode(reader, reader.uint32()));
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.appliedTags.push(reader.string());
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.defaultReactionEmoji = DefaultReaction.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.defaultThreadRateLimitPerUser = longToNumber(reader.uint64() as Long);
          continue;
        case 34:
          if (tag !== 272) {
            break;
          }

          message.defaultSortOrder = reader.int32() as any;
          continue;
        case 35:
          if (tag !== 280) {
            break;
          }

          message.defaultForumLayout = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Channel>, I>>(base?: I): Channel {
    return Channel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Channel>, I>>(object: I): Channel {
    const message = createBaseChannel();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.guildId = object.guildId ?? undefined;
    message.position = object.position ?? undefined;
    message.permissionOverwrites = object.permissionOverwrites?.map((e) => OverwriteObject.fromPartial(e)) || [];
    message.name = object.name ?? undefined;
    message.topic = object.topic ?? undefined;
    message.nsfw = object.nsfw ?? undefined;
    message.lastMessageId = object.lastMessageId ?? undefined;
    message.bitrate = object.bitrate ?? undefined;
    message.userLimit = object.userLimit ?? undefined;
    message.rateLimitPerUser = object.rateLimitPerUser ?? undefined;
    message.recipients = object.recipients?.map((e) => User.fromPartial(e)) || [];
    message.icon = object.icon ?? undefined;
    message.ownerId = object.ownerId ?? undefined;
    message.applicationId = object.applicationId ?? undefined;
    message.managed = object.managed ?? undefined;
    message.parentId = object.parentId ?? undefined;
    message.lastPinTimestamp = object.lastPinTimestamp ?? undefined;
    message.rtcRegion = object.rtcRegion ?? undefined;
    message.videoQualityMode = object.videoQualityMode ?? undefined;
    message.messageCount = object.messageCount ?? undefined;
    message.memberCount = object.memberCount ?? undefined;
    message.threadMetadata = (object.threadMetadata !== undefined && object.threadMetadata !== null)
      ? ThreadMetadata.fromPartial(object.threadMetadata)
      : undefined;
    message.member = (object.member !== undefined && object.member !== null)
      ? ThreadMember.fromPartial(object.member)
      : undefined;
    message.defaultAutoArchiveDuration = object.defaultAutoArchiveDuration ?? undefined;
    message.permissions = object.permissions ?? undefined;
    message.flags = object.flags ?? undefined;
    message.totalMessageSent = object.totalMessageSent ?? undefined;
    message.availableTags = object.availableTags?.map((e) => ForumTag.fromPartial(e)) || [];
    message.appliedTags = object.appliedTags?.map((e) => e) || [];
    message.defaultReactionEmoji = (object.defaultReactionEmoji !== undefined && object.defaultReactionEmoji !== null)
      ? DefaultReaction.fromPartial(object.defaultReactionEmoji)
      : undefined;
    message.defaultThreadRateLimitPerUser = object.defaultThreadRateLimitPerUser ?? undefined;
    message.defaultSortOrder = object.defaultSortOrder ?? undefined;
    message.defaultForumLayout = object.defaultForumLayout ?? undefined;
    return message;
  },
};

function createBaseDefaultReaction(): DefaultReaction {
  return { emojiId: undefined, emojiName: undefined };
}

export const DefaultReaction = {
  encode(message: DefaultReaction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.emojiId !== undefined) {
      writer.uint32(10).string(message.emojiId);
    }
    if (message.emojiName !== undefined) {
      writer.uint32(18).string(message.emojiName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DefaultReaction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultReaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emojiId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.emojiName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<DefaultReaction>, I>>(base?: I): DefaultReaction {
    return DefaultReaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DefaultReaction>, I>>(object: I): DefaultReaction {
    const message = createBaseDefaultReaction();
    message.emojiId = object.emojiId ?? undefined;
    message.emojiName = object.emojiName ?? undefined;
    return message;
  },
};

function createBaseForumTag(): ForumTag {
  return { id: "", name: "", moderated: false, emojiId: undefined, emojiName: undefined };
}

export const ForumTag = {
  encode(message: ForumTag, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.moderated !== false) {
      writer.uint32(24).bool(message.moderated);
    }
    if (message.emojiId !== undefined) {
      writer.uint32(34).string(message.emojiId);
    }
    if (message.emojiName !== undefined) {
      writer.uint32(42).string(message.emojiName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ForumTag {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForumTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.moderated = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.emojiId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.emojiName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ForumTag>, I>>(base?: I): ForumTag {
    return ForumTag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ForumTag>, I>>(object: I): ForumTag {
    const message = createBaseForumTag();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.moderated = object.moderated ?? false;
    message.emojiId = object.emojiId ?? undefined;
    message.emojiName = object.emojiName ?? undefined;
    return message;
  },
};

function createBaseThreadMetadata(): ThreadMetadata {
  return {
    archived: false,
    autoArchiveDuration: 0,
    archiveTimestamp: 0,
    locked: false,
    invitable: undefined,
    createTimestamp: undefined,
  };
}

export const ThreadMetadata = {
  encode(message: ThreadMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.archived !== false) {
      writer.uint32(8).bool(message.archived);
    }
    if (message.autoArchiveDuration !== 0) {
      writer.uint32(16).uint64(message.autoArchiveDuration);
    }
    if (message.archiveTimestamp !== 0) {
      writer.uint32(24).uint64(message.archiveTimestamp);
    }
    if (message.locked !== false) {
      writer.uint32(32).bool(message.locked);
    }
    if (message.invitable !== undefined) {
      writer.uint32(40).bool(message.invitable);
    }
    if (message.createTimestamp !== undefined) {
      writer.uint32(48).uint64(message.createTimestamp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.archived = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.autoArchiveDuration = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.archiveTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.locked = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.invitable = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createTimestamp = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ThreadMetadata>, I>>(base?: I): ThreadMetadata {
    return ThreadMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThreadMetadata>, I>>(object: I): ThreadMetadata {
    const message = createBaseThreadMetadata();
    message.archived = object.archived ?? false;
    message.autoArchiveDuration = object.autoArchiveDuration ?? 0;
    message.archiveTimestamp = object.archiveTimestamp ?? 0;
    message.locked = object.locked ?? false;
    message.invitable = object.invitable ?? undefined;
    message.createTimestamp = object.createTimestamp ?? undefined;
    return message;
  },
};

function createBaseThreadMember(): ThreadMember {
  return { id: undefined, userId: undefined, joinTimestamp: 0, flags: 0, member: undefined };
}

export const ThreadMember = {
  encode(message: ThreadMember, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== undefined) {
      writer.uint32(18).string(message.userId);
    }
    if (message.joinTimestamp !== 0) {
      writer.uint32(24).uint64(message.joinTimestamp);
    }
    if (message.flags !== 0) {
      writer.uint32(32).uint64(message.flags);
    }
    if (message.member !== undefined) {
      GuildMember.encode(message.member, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ThreadMember {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThreadMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.joinTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.flags = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.member = GuildMember.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ThreadMember>, I>>(base?: I): ThreadMember {
    return ThreadMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ThreadMember>, I>>(object: I): ThreadMember {
    const message = createBaseThreadMember();
    message.id = object.id ?? undefined;
    message.userId = object.userId ?? undefined;
    message.joinTimestamp = object.joinTimestamp ?? 0;
    message.flags = object.flags ?? 0;
    message.member = (object.member !== undefined && object.member !== null)
      ? GuildMember.fromPartial(object.member)
      : undefined;
    return message;
  },
};

function createBaseOverwriteObject(): OverwriteObject {
  return { id: "", type: 0, allow: "", deny: "" };
}

export const OverwriteObject = {
  encode(message: OverwriteObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.allow !== "") {
      writer.uint32(26).string(message.allow);
    }
    if (message.deny !== "") {
      writer.uint32(34).string(message.deny);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OverwriteObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOverwriteObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allow = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deny = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<OverwriteObject>, I>>(base?: I): OverwriteObject {
    return OverwriteObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OverwriteObject>, I>>(object: I): OverwriteObject {
    const message = createBaseOverwriteObject();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.allow = object.allow ?? "";
    message.deny = object.deny ?? "";
    return message;
  },
};

function createBaseApplicationCommandCounts(): ApplicationCommandCounts {
  return { messages: undefined, users: undefined, chatInputs: undefined };
}

export const ApplicationCommandCounts = {
  encode(message: ApplicationCommandCounts, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.messages !== undefined) {
      writer.uint32(8).uint64(message.messages);
    }
    if (message.users !== undefined) {
      writer.uint32(16).uint64(message.users);
    }
    if (message.chatInputs !== undefined) {
      writer.uint32(24).uint64(message.chatInputs);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ApplicationCommandCounts {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationCommandCounts();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.messages = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.users = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.chatInputs = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ApplicationCommandCounts>, I>>(base?: I): ApplicationCommandCounts {
    return ApplicationCommandCounts.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationCommandCounts>, I>>(object: I): ApplicationCommandCounts {
    const message = createBaseApplicationCommandCounts();
    message.messages = object.messages ?? undefined;
    message.users = object.users ?? undefined;
    message.chatInputs = object.chatInputs ?? undefined;
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    username: "",
    discriminator: "",
    globalName: undefined,
    avatar: undefined,
    bot: undefined,
    system: undefined,
    mfaEnabled: undefined,
    banner: undefined,
    accentColor: undefined,
    locale: undefined,
    verified: undefined,
    email: undefined,
    flags: undefined,
    premiumType: undefined,
    publicFlags: undefined,
    avatarDecoration: undefined,
  };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.discriminator !== "") {
      writer.uint32(26).string(message.discriminator);
    }
    if (message.globalName !== undefined) {
      writer.uint32(34).string(message.globalName);
    }
    if (message.avatar !== undefined) {
      writer.uint32(42).string(message.avatar);
    }
    if (message.bot !== undefined) {
      writer.uint32(48).bool(message.bot);
    }
    if (message.system !== undefined) {
      writer.uint32(56).bool(message.system);
    }
    if (message.mfaEnabled !== undefined) {
      writer.uint32(64).bool(message.mfaEnabled);
    }
    if (message.banner !== undefined) {
      writer.uint32(74).string(message.banner);
    }
    if (message.accentColor !== undefined) {
      writer.uint32(80).uint64(message.accentColor);
    }
    if (message.locale !== undefined) {
      writer.uint32(90).string(message.locale);
    }
    if (message.verified !== undefined) {
      writer.uint32(96).bool(message.verified);
    }
    if (message.email !== undefined) {
      writer.uint32(106).string(message.email);
    }
    if (message.flags !== undefined) {
      writer.uint32(112).uint64(message.flags);
    }
    if (message.premiumType !== undefined) {
      writer.uint32(120).int32(message.premiumType);
    }
    if (message.publicFlags !== undefined) {
      writer.uint32(128).uint64(message.publicFlags);
    }
    if (message.avatarDecoration !== undefined) {
      writer.uint32(138).string(message.avatarDecoration);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.discriminator = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.globalName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.bot = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.system = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.mfaEnabled = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.banner = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.accentColor = longToNumber(reader.uint64() as Long);
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.locale = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.verified = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.email = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.flags = longToNumber(reader.uint64() as Long);
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.premiumType = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.publicFlags = longToNumber(reader.uint64() as Long);
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.avatarDecoration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.discriminator = object.discriminator ?? "";
    message.globalName = object.globalName ?? undefined;
    message.avatar = object.avatar ?? undefined;
    message.bot = object.bot ?? undefined;
    message.system = object.system ?? undefined;
    message.mfaEnabled = object.mfaEnabled ?? undefined;
    message.banner = object.banner ?? undefined;
    message.accentColor = object.accentColor ?? undefined;
    message.locale = object.locale ?? undefined;
    message.verified = object.verified ?? undefined;
    message.email = object.email ?? undefined;
    message.flags = object.flags ?? undefined;
    message.premiumType = object.premiumType ?? undefined;
    message.publicFlags = object.publicFlags ?? undefined;
    message.avatarDecoration = object.avatarDecoration ?? undefined;
    return message;
  },
};

function createBaseGuildMember(): GuildMember {
  return {
    user: undefined,
    nick: undefined,
    avatar: undefined,
    roles: [],
    joinedAt: 0,
    premiumSince: undefined,
    deaf: false,
    mute: false,
    flags: 0,
    pending: undefined,
    permissions: undefined,
    communicationDisabledUntil: undefined,
  };
}

export const GuildMember = {
  encode(message: GuildMember, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.nick !== undefined) {
      writer.uint32(18).string(message.nick);
    }
    if (message.avatar !== undefined) {
      writer.uint32(26).string(message.avatar);
    }
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.joinedAt !== 0) {
      writer.uint32(40).uint64(message.joinedAt);
    }
    if (message.premiumSince !== undefined) {
      writer.uint32(48).uint64(message.premiumSince);
    }
    if (message.deaf !== false) {
      writer.uint32(56).bool(message.deaf);
    }
    if (message.mute !== false) {
      writer.uint32(64).bool(message.mute);
    }
    if (message.flags !== 0) {
      writer.uint32(72).uint64(message.flags);
    }
    if (message.pending !== undefined) {
      writer.uint32(80).bool(message.pending);
    }
    if (message.permissions !== undefined) {
      writer.uint32(90).string(message.permissions);
    }
    if (message.communicationDisabledUntil !== undefined) {
      writer.uint32(96).uint64(message.communicationDisabledUntil);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GuildMember {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuildMember();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nick = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.avatar = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.joinedAt = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.premiumSince = longToNumber(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deaf = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.mute = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.flags = longToNumber(reader.uint64() as Long);
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.pending = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.permissions = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.communicationDisabledUntil = longToNumber(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GuildMember>, I>>(base?: I): GuildMember {
    return GuildMember.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GuildMember>, I>>(object: I): GuildMember {
    const message = createBaseGuildMember();
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.nick = object.nick ?? undefined;
    message.avatar = object.avatar ?? undefined;
    message.roles = object.roles?.map((e) => Role.fromPartial(e)) || [];
    message.joinedAt = object.joinedAt ?? 0;
    message.premiumSince = object.premiumSince ?? undefined;
    message.deaf = object.deaf ?? false;
    message.mute = object.mute ?? false;
    message.flags = object.flags ?? 0;
    message.pending = object.pending ?? undefined;
    message.permissions = object.permissions ?? undefined;
    message.communicationDisabledUntil = object.communicationDisabledUntil ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
